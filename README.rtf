A cache simulator that you will use to evaluate and compare the cache hit rates for several cache architectures. \
Given a cache memory organization, your simulator should read a file containing a memory trace (a sequence of memory addresses) and determine which of the memory references will cause cache hits (and which will cause misses). The program should keep track of the number of hits and misses generated by each cache over the entire trace. For every memory access you will need to update your cache data structures and update any cache statistics (more on this later).\

Three trace files are available in the Traces folder. Each line has three fields.\

The first field gives the type of the memory reference (2 for instruction fetch, 1 for a store's data memory write, and 0 for a load's data memory read).\

The second field on the line is the address.\

The third field gives the instruction value for a fetch and is always 0 for loads and stores (Not used in this lab).\

For e.g., the gcc trace file has 1,000,000 memory references (one per line) and was collected from the gcc while it was running on a MIPS processor.\

 Your task is to simulate an architecture with a writeback cache --a data cache (D-cache). The cache will be placed between the CPU and memory. The data cache will be used to cache data reads/writes. The cache will use an LRU replacement policy.\
When initializing the cache, you will be given a block size, a cache size and an associativity (maximum of 32) -- these will always be powers of 2.\
For every access your cache makes, you will be provided an address and an access type (mem read, mem write, or instruction read). For every cache access, you will need to update the data structures you are using and the cache statistics to reflect the occurrence of that cache access. The statistics you will need to keep track of are the total accesses, total misses, D-cache accesses, D-cache misses and writebacks.\

For each cache block you need to keep track of the tag, valid bit, and dirty bit (was the cache line modified?). For each set you need to keep track of the LRU status of the blocks in the set. Dynamically allocate and create the directory data structure.\

Read and process each address from the trace file -- read a memory reference, extract the index and tag, determine whether it is a hit or a miss, update the directory structure and any other data structures you add (for example counters keeping track of the number of hits or number of references). Do not forget to update the LRU status.\

You are simulating only one cache configuration at a time.\

Compiling LRU stack test:\
gcc lrustack.h lrustack.c lrustacktest.c -o lrustacktest

Running LRU stack test:\

./lrustacktest\

Compiling the cache simulator:\
gcc lrustack.h lrustack.c cachesim.h cachesim.c -o cachesim\

Running the cache simulator:\
./cachesim <trace> <block_size>, <cache_size>,\
<associativity>\

Expected outputs:\
The Tests folder lists the sample outputs for the three traces provided. \
\
Determine hit rates, miss rates, and writeback traffic for various configuration of a 
64 Kbyte unified set associative cache
\(instruction and data), assuming a cold cache for each trace - the cache is initially empty and all lines are in the invalid state. The cache configuration is a combination of the line size and associativity. 
Configuration parameters include: cache block size (32 byte, 64 byte, 128 byte, 256 byte, and 512 byte) and associativity (2, 4, 8)

\
}
